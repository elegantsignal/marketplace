# Marketplace project description

## TOD

- тип хэширования паролей
- проверка типа файла с помощью Тикка
-  

<div class="page-break"></div>

## Nota Bene

### Get list of all user's orders

We need to show all user's orders with bought products and download links for each product. I found several solutions:

- Get all user's orders, then for each order get order item. Obvious that it is not good solution because we have unpredictable number of database queries.

- Use OneToMany relationship. It looks better, but we can suggest that we don't know how many data will be pulled cascaded from DB (other tables depended on `order` may have OneToMany relationship).

- Get all order items with one query and work with them. But we will need to groupe them in some way.

The last solution was chosen. We get all order items then map them to orders. You can found that `OrderItem` have `@OneToMany` relationship to `download`, we admit that because `download` table have only one relationship (with `order_item`).

<div style="page-break-after: always;"></div>

Final sql generated by `OrderItemDaoImp.find()` looks like this:

```sql
SELECT
  order_item.id,
  product.id,
  book.id,
  "order".id,
  download.id
  -- Other data from all tables
FROM
  order_item
  LEFT OUTER JOIN product ON order_item.product_id = product.id
  LEFT OUTER JOIN book ON product.id = book.id
  LEFT OUTER JOIN "order" ON order_item. "order_id" = "order".id
  LEFT OUTER JOIN download ON order_item.id = download.order_item_id
WHERE
  "order"."user_id" = 1;

```

Convert `List<IOrderItem>` to `List<Order>`:

```java
@Override public List<IOrder> getOrdersByUserId(final Integer userId) {
  final List<IOrderItem> orderItemList = orderItemService.getOderItemsByUserId(userId);

  final Set<IOrder> orderSet = new HashSet<>();
  orderItemList.forEach(orderItem ->
    orderSet.add(orderItem.getOrder().addOrderItem(orderItem))
  );

  final List<IOrder> orderList = new ArrayList<>(orderSet);
  orderList.sort((o2, o1) -> o1.getCreated().compareTo(o2.getCreated()));
  return orderList;
}
```

We use `Set` to avoid to search proper **order** in list, on the other hand - we need to convert them to sorted list.

<div style="page-break-after: always;"></div>

### Download benchmark (public vs static files)

#### Test on Jetty

We need to chouse how to server static files. Let's consider two solution: serving by servlet and serving by our app as InputStream.

We perform three test:

1. access file from servlet (we will use Jetty)
2. access file from our app
3. access protected file from app (we will need to make database query to get the file)

![jetty-jmeter](presentation.assets/jetty-jmeter.png)

![jetty-visualvm](presentation.assets/jetty-visualvm.png)

As we can see we have similar resource usage, and response time for both solutions. Even Jetty show little worse performance then our app. So let's test it on Tomcat.

<div style="page-break-after: always;"></div>

#### Test on Tomcat

![tomcat - jmeter](presentation.assets/tomcat%20-%20jmeter.png)![tomcat - visualvm](presentation.assets/tomcat%20-%20visualvm.png)

 OK. On Tomcat we got expected results. But why access to protected file took two times as long as access on Jetty? I don't know.

As conclusion we can say that both solutions are very slow and resource hungry. Java servlets are not suitable for file serving, we should use proper tool like Nginx for that.

<div style="page-break-after: always;"></div>

## Deployment

### Java in Docker - the right way (almost)

#### Dockerfile

```dockerfile
FROM maven:3.6.3-jdk-8 AS builder
WORKDIR /usr/src/app

COPY pom.xml .
COPY dao/pom.xml dao/pom.xml
COPY service/pom.xml service/pom.xml
COPY web/pom.xml web/pom.xml
COPY web/src/main/webapp/WEB-INF/web.xml web/src/main/webapp/WEB-INF/web.xml
RUN  mvn package && mvn clean

COPY ./ .
RUN  mvn package -DskipTests



FROM tomcat:9-jre8-alpine
WORKDIR ${CATALINA_HOME}

RUN  rm -rf webapps/*
COPY config/tomcat/server.xml config/tomcat/context.xml conf/
COPY --from=builder /usr/src/app/web/target/${APP_NAME}.war webapps/ROOT.war

RUN  addgroup www-data && \
     adduser -D -H -u 1000 -s /bin/bash www-data -G www-data && \
     chown -R www-data:www-data webapps temp

USER www-data
CMD  ["catalina.sh", "run"]
```

.war size 47Mb, final docker image size 200Mb and `builder` image size is bigger then 800Mb.

> NB In modern world we should use [Embedded Tomcat](https://devcenter.heroku.com/articles/create-a-java-web-application-using-embedded-tomcat).
