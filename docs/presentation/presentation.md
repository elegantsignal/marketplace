

# Marketplace project description

<div class="page-break"></div>

## Nota Bene

### Get list of all user's orders

We need to show all user's orders with bought products and download links for each product. I found several solutions:

- Get all user's orders, then for each order get order item. Obvious that it is not good solution because we have unpredictable number of database queries.

- Use OneToMany relationship. It looks better, but we can suggest that we don't know how many data will be pulled cascaded from DB (other tables depended on `order` may have OneToMany relationship).

- Get all order items with one query and work with them. But we will need to groupe them in some way.

The last solution was chosen. We get all order items then map them to orders. You can found that `OrderItem` have `@OneToMany` relationship to `download`, we admit that because `download` table have only one relationship (with `order_item`).

<div style="page-break-after: always;"></div>

Final sql generated by `OrderItemDaoImp.find()` looks like this:

```sql
SELECT
  order_item.id,
  product.id,
  book.id,
  "order".id,
  download.id
  -- Other data from all tables
FROM
  order_item
  LEFT OUTER JOIN product ON order_item.product_id = product.id
  LEFT OUTER JOIN book ON product.id = book.id
  LEFT OUTER JOIN "order" ON order_item. "order_id" = "order".id
  LEFT OUTER JOIN download ON order_item.id = download.order_item_id
WHERE
  "order"."user_id" = 1;

```

Convert from `OrderItem` to `List<Order>`:

```java
@Override public List<IOrder> getOrdersByUserId(final Integer userId) {
  final List<IOrderItem> orderItemList = orderItemService.getOderItemsByUserId(userId);

  final Set<IOrder> orderSet = new HashSet<>();
  orderItemList.forEach(orderItem ->
    orderSet.add(orderItem.getOrder().addOrderItem(orderItem))
  );

  final List<IOrder> orderList = new ArrayList<>(orderSet);
  orderList.sort((o2, o1) -> o1.getCreated().compareTo(o2.getCreated()));
  return orderList;
}
```

We use `Set` to avoid to search proper **order** in list, on the other hand - we need to convert them to sorted list.

<div style="page-break-after: always;"></div>

### Download benchmark (public vs static files)

#### Test on Jetty

We need to chouse how to server static files. Let's consider two solution: serving by servlet and serving by our app as InputStream.

We perform three test:

1. access file from servlet (we will use Jetty)
2. access file from our app
3. access protected file from app (we will need to make database query to get the file)

![jetty-jmeter](presentation.assets/jetty-jmeter.png)

![jetty-visualvm](presentation.assets/jetty-visualvm.png)

As we can see we have similar resource usage, and response time for both solutions. Even Jetty show little worse performance then our app. So let's test it on Tomcat.

<div style="page-break-after: always;"></div>

#### Test on Tomcat

![tomcat - jmeter](presentation.assets/tomcat%20-%20jmeter.png)![tomcat - visualvm](presentation.assets/tomcat%20-%20visualvm.png)

 OK. On Tomcat we got expected results. But why access to protected file took two times as long as access on Jetty? I don't know.

As conclusion we can say that both solutions are very slow and resource hungry. Java servlets are not suitable for file serving, we should use proper tools like Nginx for that.